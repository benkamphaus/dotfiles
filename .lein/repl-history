% -2 3
(% -2 3)
(mod -2 3)
exit
(+ 2 3)
(println "hello")
ls
!ls
exit
(defn hello [user] (str "Hello, " user))
(hello "Ben")
(hello "Katie")
(helllo "Katie")
(hello "Katie")
(str *1)
(str *2_
)
(str *2)
(str *4)
(str *3)
(/ 1 0)
(/ 2 3)
(/ 2 3.0)
(mod 1 3)
(mod -1 3)
quit
(load-file "test.clj")
(hello "Ben")
ls -a
exit
(take 5 (iterate inc 5))
(take 10 (iterate (partial +2) 0))
(take 10 (iterate (partial +2 ) 0))
(take 10 (iterate (partial + 2) 0))
(nth #(* % %) 2)
(nth #(* % 2) 2)
(def powers-of-two (iterate (partial * 2) 1))
(nth powers-of-two 10)
(nth powers-of-two 6)
(nth powers-of-two 312)
(nth powers-of-two 60)
(defn indexed [coll] (map-indexed vector coll))
(indexed "abcde")
(defn index-filter [pred coll]
  (when pred
    (for [[idx elt] (indexed coll) :when (pred elt)] idx)))
(index-filter #{\a \b} "abcdbbb")
(def someseq [1 2 3 3 4 5])
(first someseq)
(last someseq)
(bf someseq)
(butfirst someseq)
(rest someseq)
(cons 1 someseq)
(next someseq)
(rest someseq)
(seq someseq)
(first '(1 2 3))
(rest '(1 2 3))
(cons 0 '(1 2 3))
(first [1 2 3])
(rest [1 2 3])
(cons 0 [1 2 3])
(cons '+ [1 2 3])
((cons '+ [1 2 3]))
(* '(cons '+ [1 2 3]))
(int (1 2 3) (:a :b :c))
(into (1 2 3) (:a :b :c))
(into '(1 2 3) '(:a :b :c))
(range 10)
(map #(% * 2) (range 10))
(map #(% * 2) (vec (range 10)))
(vec (range 10))
(map #(* 2 %) (vec (range 10)))
(map #(* 2 %) (range 10))
(take 4 (cycle (range 3)))
(take 7 (cycle (range 3)))
(range 10)
(map #(* % 2) (range 10))
(take 4 (map #(* % 2) (range 10)))
ll
(load visitors)
(load test)
(load "test")
ll
(map #(* % %) take 4 (iterate inc 3))
(map #(* % %) (take 4 (iterate inc 3)))
ll
q
quit
(def person {:name Ben :age 33 :weight 180}
)
(def person {:name "Ben" :age 33 :weight 180}
)
(:name person)
("Ben" person)
(:name person)
(:age person)
(:weight person)
exit
(take 3 (repeat 2))
(def whole-numbers (iterate inc 1))
(take 6 whole-numbers)
(take 10 (cycle (range 2)))
(interleave (whole-numbers) ["A" "B" "C" "D"])
(interleave whole-numbers ["A" "B" "C" "D"])
(filter even? whole-numbers)
(filter even? (take 5 whole-numbers))
(filter even? (take 9 whole-numbers))
(drop-while even? (take 9 whole-numbers))
(take-while even? (take 9 whole-numbers))
(splie-at 5 (range 10))
(split-at 5 (range 10))
(cons (split-at 5 (range 10)))
(map (split-at 5 (range 10)))
(join (split-at 5 (range 10)))
(every? even? [1 3 5])
(some? even? [ 1 2 5])
(some even? [ 1 2 5])
(any? even? [1 2 3])
(not-any? even? [1 2 3])
(not-any? even? [1 3 5])
(reduce + (range 1 11))
(reduce * (range 1 11))
(sort < (range 10))
(sort > (range 10))
(for [number (range 10)]
  (str number))
(map str (range 10))
(apply str (range 10))
(for [number (range 10)]
  :when (even? number) (str number))
(for [number (range 10)
  :when (even? number) (str number)])
(for [number (range 10) :when (even? number)] (str number))
(first .getBytes "hello")
(first (.getBytes "hello"))
(rest (.getBytes "hello"))
(first "Hello")
(rest "Hello")
(first (rest "Hello"))
(reverse "hello")
(apply str (reverse "hello"))
(re-seq #"\w+" "the quick brown fox")
(re-seq #"th*" (re-seq #"\w+" "the quick brown fox"))
mport '(java.io File))
(import '(java.io File))
(.listFile (File. "."))
(.listFiles (File. "."))
(.listFiles (File. "/usr/bin/."))
quit
(load "test")
(hello "Ben")
(hello "Katie")
visitors
(load "test")
(stack-consuming-fibo 10)
(stack-consuming-fibo 100000)
(load "test")
(tail-fibo 100000)
(tail-fibo 100)
(load "test")
(recur-fibo 10000)
(recur-fibo 1000000)
(load "test.clj")
(load "test")
(lazy-seq-fibo 10)
(take 10 (lazy-seq-fibo))
(rem (nth (lazy-seq-fibo) 1000000) 1000)
(defn fibo []
  (map first (iterate (fn [[a b]] [b (+ a b)]) [0N 1N])))
(take 5 (fibo))
(rem (nth (fibo) 1000000) 1000)
(def lots-o-fibs (take 10000000 (fibo)))
(nth lots-o-fibs 100)
(nth lots-o-fibs 10000)
(nth lots-o-fibs 100000)
(load "test")
(by-pairs [:h :t :t :h :h :h])
(defn count-heads-pairs [coll]
  (count (filter (fn [pair] (every? #(= :h %) pair))
                 (by-pairs coll))))
(count-head-pairs [:h :t :t :h :h :h :t :h :t :h :h])
(count-heads-pairs [:h :t :t :h :h :h :t :h :t :h :h])
(partition 2 [:h :t :t :h :h :h])
(partition 2 1 [:h :t :t :h :h :h])
(defn by-pairs [coll]
  (partition 2 1 coll))
(by-pairs [:h :t :t :h :h :h])
(def count-if (comp count filter))
(count-if odd? [1 2 3 4 5])
(defn count-runs [n pred coll] [count-if #(every? pred %) (partition n 1 coll)))
(defn count-runs [n pred coll] [count-if #(every? pred %) (partition n 1 coll))
(defn count-runs [n pred coll] [count-if #(every? pred %) (partition n 1 coll))))
(defn count-runs [n pred coll] (count-if #(every? pred %) (partition n 1 coll))))
(defn count-runs [n pred coll] (count-if #(every? pred %) (partition n 1 coll)))
(count-runs 2 #(= % :h) [:h :t :t :h :h :h])
(count-runs 3 #(= % :h) [:h :t :t :h :h :h])
(count-runs 2 #(= % :t) [:h :t :t :h :h :h])
(def count-heads-pairs (partial count-runs 2 #(= % :h)))
quit
(quit)
(println "ok)
")
(print "ok")
(take 3 (inc 1))
(take 3 (do (inc 1)))
(take 3 (doseq (inc 1)))
(take 3 (doseq (inc 1 1)))
(take 2 (inc 1 1))
([])
(2 [:a :b :c])
([:a :b :c] 2)
([:a :b :c] 1)
exit
(load "sq")
(bk-sqrt 2)
(bk-sqrt 3)
(bk-sqrt 5)
exit
(load "sq")
(bk-sqrt 2)
(bk-sqrt 1)
(bk-sqrt 1.1)
(bk-sqrt 1.2)
(bk-sqrt 1.3)
exit
(+)
(*)
(+ 1 2 3 4 5)
(conj 1 2 3)
(cons 1 2 3)
(cons 1 (2 3))
(cons (1 2) 3)
clear
quit
(println "ok")
exit
(use '[datomic.api :only [q db] :as d])
exit
(use '[datomic.api :only [q db] :as d])
(load "repl")
(load "datomic.clj")
exit
(require [com.datomic/datomic-free "0.9.4752"])
(quit)
(require [com.datomic/datomic-free "0.9.4752"])
(require com.datomic)
(use datomic)
(require 'com.datomic/datomic-free)
(require 'com.datomic
)
(require '[com.datomic/datomic-free "0.9.4752"])
(require ['clojure.string :as 'string'])
(string/capitalize "foo")
('string/capitalize "foo")
(require '[clojure.string :as string])
(string/capitalize "foo")
(println (string/capitalize "foo"))
(def tlist '(1 2 3 4 5))
(zipmap tist (repeat 1))
(zipmap tlist (repeat 1))
(sum (map second (zipmap tlist (repeat 1))))
(reduce + (map second (zipmap tlist (repeat 1))))
(reduce + (map second (zipmap "Hello world" (repeat 1))))
(zipmap "Hello world" (repeat 1))
(map #(mod %1 2) '(1 2 3))
(filter #(= (mod %1 2) 1) '(1 2 3))
(#(vec %&) 1 2 3)
(reduce + (#(vec %&) 1 2 3))
(reduce > (#(vec %&) 1 2 3))
#
(reduce (fn [x y] (cond (> x y) x) :else y) (vec %&))
#(reduce (fn [x y] (cond (> x y) x) :else y) (vec %&))
(#(reduce (fn [x y] (cond (> x y) x) :else y) (vec %&)) 1 2 3)
(#(reduce (fn [x y] (cond (> x y) x) :else y) (vec %&)) 45 67 11)
(reduce (fn [x y] (cond (> x y) x) :else y) (vec %&)) 45 67 11)
(> 1 2)
(>  2 1)
(filter #(= %1 clojure.string/upper-case %1) "aBcD")
(= "a" "a")
(= "a" "A")
(clojure.string/upper-case "aBcD")
(clojure.string/upper-case (seq "aBcD"))
((fn [a] filter #(= %1 clojure.string/upper-case %1) (seq a)) "aBcD")
((fn [a] filter #(= %1 (clojure.string/upper-case %1)) (seq a)) "aBcD")
(map #(= %1 (clojure.string/upper-case %1)) (seq "aBcD"))
(#(= %1 (clojure.string/upper-case %1)) "a")
(#(= %1 (clojure.string/upper-case %1)) "A")
(#(= %1 (clojure.string/upper-case %1)) "abCD")
(filter #(= %1 (clojure.string/upper-case %1)) "abCD")
(filter #(= %1 (clojure.string/upper-case %1)) (seq "abCD"))
(filter #(= %1 (clojure.string/upper-case %1)) (vec "abCD"))
(vec "abcd")
(filter (fn [a] (= a (clojure.string/upper-case a)) "abcd"))
(filter (fn [a] (= a (clojure.string/upper-case a)) (seq "abcd"))
)
(filter (fn [a] (= a (clojure.string/upper-case a))) (seq "abcd")
)
(quit)
